# 2.4面向对象之多态

### 一、多态(Polymorphism)

* 子类就是父类（玫瑰是花，男人是人），因此多态的意思就是：**父类型的引用可以指向子类的对象**。 
  
  >eg
  
      People people = new Man();

* 当使用多态方式调用方法时，首先检查父类中是否有 sing()方法，如果没有则编译错误；如果有，再去调用子类的 sing()方法。 

  >eg
  
      Parent p = new Child();
      p.sing();

### 二、强制类型转换（向上类型转换、向下类型转换）

* 向上类型转换（upcast）：比如说将 Cat 类型转换为 Animal 类型，即将**子类型转换为父类型**。对于向上类型转换，不需要显式指定。 

  >eg
  
      Animal animal = new Cat();
      animal.sing();

* 向下类型转换（downcast）：比如将 Animal 类型转换为 Cat 类型。即将**父类型转换为子类型**。对于向下类型转换，必须要显式指定（必须要使用强制类型 转换）。 

  >eg
  
      Animal animal = new Cat();
      Cat cat = (Cat) animal;
      cat.sing();
  
### 三、抽象类、抽象方法

*  抽象类（abstract class）： 使用了 abstract 关键字所修饰的 类叫做抽象类。抽象类无法实例化，也就是说，不能 new 出来一个抽象类的对象（实例）。 

   >eg

       abstract class Test{

       }

* 抽象方法（abstract method）： 使用 abstract 关键字所修饰的方法叫做抽象方法。抽象方法需要定义在抽象类中。相对于抽象方法，之前所定义的方法叫做具体方法（**有声明，有实现**）。 <抽象方法默认是public的>

  >eg

      public abstract void testMethod();

* 抽象类与抽象方法

    * 如果一个类包含了抽象方法，那么这个类一定是抽象类。 

    * 如果某个类是抽象类，那么该类可以包含具体方法（有声明、有实现）。 

    * 如果一个类中包含了抽象方法，那么这个类一定要声明成 abstract class，也就是说，该类一定是抽象类；反之，如果某个类是抽象类，那么该类既可以包含抽象方法，也可以包含具体方法。 
    
    * 总结：
    
        * 1>可以为空
        
        * 2>可以全为具体方法
        
        * 3>可以全为抽象方法
        
        * 4>可以有具体方法，也可以有抽象方法

* 无论何种情况，只要一个类是抽象类，那么这个类就无法实例化。 

* 继承抽象类

    *  在子类继承父类（父类是个抽象类）的情况下，那么该子类必须要实现父类 中所定义的所有抽象方法；否则，该子类需要声明成一个 abstract class。
























