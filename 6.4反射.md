# 6.4反射

### 一、Java语言的反射机制：

* 1、在`Java`运行时环境中，对于任意一个类，皆可**知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法**。这种动态获取类的信息以及动态调用对象的方法的功能来自于`Java` 语言的反射（ `Reflection`）机制。 

*  2、Java 反射机制的功能

   * 在运行时判断任意一个对象所属的类。 

   * 在运行时构造任意一个类的对象。 

   * 在运行时判断任意一个类所具有的成员变量和方法。 

   * 在运行时调用任意一个对象的方法

* 3、Reflection 是 Java 被视为动态（或准动态）语言的一个关键性质。

   * 这个机制允许程序在运行时透过`Reflection APIs`取得任何一个**已知名称**的`class`的内部信息，包括其 修饰符（`modifiers` 诸如 `public`, `static` 等等）、`superclass`（ 例如 `Object`）、实现之`interfaces`（例如 `Serializable`） ，也包括 `fields` 和 `methods` 的所有信息，**并可于运行时改变 `fields` 内容或调用 `methods`**。

   * **通过反射，可以调用一个类的 私有方法 和改变 私有成员变量，打破类的包装机制，实现正常情况下无法实现的需求。**


* 4、动态语言：**程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言**。从这个观点看，`Perl`，`Python` ，`Ruby`是动态语言，`C++`，`Java`，`C#` 不是动态语言

* 5、尽管在这样的定义与分类下Java不是动态语言， 它却有着一个非常突出的动态相关机制： `Reflection`。这个字的意思是  **反射、映象、倒影** ，用在Java身上指的是我们可以**在运行时加载、探知、使用编译期间完全未知的classes**。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括 methods定义），并生成其对象实体、或对其 fields设值、或唤起其methods。

     * 这种“看透 class”的能力（the ability of the program to examine itself）被称为introspection（内省、 内观、反省）。Reflection和introspection是常被并提的两个术语

### 二、Java Reflection API

* 1、在JDK中，主要由以下类来实现Java反射机制，这些类都 位于java.lang.reflect包中 

    * – Class类：代表一个类。 (位于 `java.lang` 包中)

    * – Field 类：代表类的成员变量（成员变量也称为类的属性）。 

    * – Method类：代表类的方法。 

    * – Constructor 类：代表类的构造方法。 

    * – Array类：提供了动态创建数组，以及访问数组的元素的静态方法

* 2、Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。 

* 3、要想使用反射，首先需要获得待处理类或对象所对应的 Class 对象。 

* 4、获取某个类或某个对象所对应的 Class 对象的常用的 3 种方式： 

    * 使用 `Class` 类的静态方法: ``forName：Class.forName(“java.lang.String”); ``

    * 使用类的 `.class` 语法: ``String.class;``

    * 使用对象的 `getClass()`方法: ``String s = "aa";  Class<?> clazz = s.getClass();``

* 5、若想通过类的不带参数的构造方法来生成对象，我们有两种方式： 

    * 1>先获得 Class 对象，然后通过该 Class 对象的 newInstance()方法直接生成即可： 
    
          Class<?> classType = String.class;  
          Object obj = classType.newInstance(); 

    * 2>先获得 Class 对象，然后通过该对象获得对应的 Constructor 对象，再通过该 Constructor 对象的 newInstance()方法生成： 
    
          Class<?> classType = Customer.class;  
          Constructor cons = classType.getConstructor(new Class[]{});  
          Object obj = cons.newInstance(new Object[]{}); 

* 6、若想通过类的带参数的构造方法生成对象，只能使用下面这一种方式： 

      Class<?> classType = Customer.class;  
      Constructor cons = classType.getConstructor(new Class[]{String.class, int.class}); 
      Object obj = cons.newInstance(new Object[]{“hello”, 3}); 

* 7、`Integer.TYPE` 返回的是 int，而 `Integer.class` 返回的是 Integer 类所对应的 Class 对象。 

  >eg:
  
      System.out.println(Integer.TYPE);//输出：int
      System.out.println(Integer.class);//输出：class java.lang.Integer  

* 8、例程 TestReflection 类演示了Reflection API的 基本作用，它读取命令行参数指定的类名，然后打印这个类所具有的方法信息。

      package com.edu.test;

      import java.lang.reflect.Method;

      public class TestReflection {
        public static void main(String[] args) throws ClassNotFoundException {
          Class<?> classType = Class.forName("java.lang.String");
          Method[] methods = classType.getDeclaredMethods();
          for(Method method : methods) {
            System.out.println(method);
          }
        }
      }

* 9、反射的各种常用方法

  * 1>`java.lang.Object`类中
  
      * `getClass()`方法：返回一个对象的类型
  
  * 2>`java.lang.Class`类中
  
      * `getName()`：获得类的完整名字。 
      * `getFields()`：获得类的public类型的属性。 
      * `getDeclaredFields()`：获得类的所有属性。 
      * `getMethods()`：获得类的public类型的方法。 
      * `getDeclaredMethods()`：获得类的所有方法。
      * `getMethod(String name, Class[] parameterTypes)`：获得类的特定方法，name 参数指定方法的名字，parameterTypes 参数指 定方法的参数类型。
      * `getConstructors()`：获得类的public类型的构 造方法。 
      * `getConstructor(Class[] parameterTypes)`： 获得类的特定构造方法，parameterTypes 参数 指定构造方法的参数类型。 
      * `newInstance()`：通过类的不带参数的构造方法 创建这个类的一个对象。
* 10、Method类的 `invoke(Object obj,Object args[])`方法:

  * 接收的参数必须为对象，如果参数为基本类型数据，必须转换为相应的包装类型的对象。
  
  * `invoke()`方法的返回值总是对象，如果实际被调用的方法的返回类型是基本类型数据 ，那么invoke()方法会把它转换为相应的包装类型的对象 ，再将其返回。  
  
  * 调用由该方法对象所表示的底层方法，在指定的对象上使用指定的参数。


### 三、`Class` 类

* 1、Java 中的 Object 类是所有 Java classes 的继承根源，其内声明了数个应该在所有 Java class 中被改写的 methods：

    * hashCode()、

    * equals()、 

    * clone()、

    * toString()、

    * getClass()等。

    * 其中getClass()返回一个 Class object。

* 2、 `Class`类 十分特殊

    * 它和一般类一样继承自 Object，其实体用以表达Java程序运行时的 `classes` 和 `interfaces`，也用来表达 `enum`、`array`、primitive Java types （boolean, byte, char, short, int, long, float, double）以及关键词 `void` 。当一个类被加载，或当加载器（class loader）的 `defineClass()`被JVM 调用， JVM 便自动产生一个 Class object。如果想借由 “改Java标准库源码” 来观察 lass object 实际生成时 机（例如在 Class 的 constructor 内添加一个`println()`）  不能实现！因为Class并没有 public constructor（公共的构造方法）。

* 3、Class是Reflection起源。针对任何您想探 勘的class，唯有先为它产生一个Class object，接下来才能经由后者唤起为数十 多个的Reflection APIs





