<div align=center><h1>5.3 泛型数组列表</h1></div>

* 1、解决运行时动态更改数组的问题最简单的方法是使用 Java 中另外一个被称为ArrayList 的类。它使用起来有点像数组，但在添加或删除元素时，具有自动调节数组容量的功能，而不需要为此编写任何代码。
* 2、ArrayList 是一个采用类型参数（type parameter) 的泛型类（generic class)。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如，`ArrayList<Employee>`。
* 3、声明和构造一个保存 Employee 对象的数组列表：
  ```java
  ArrayList<Employee> staff = new ArrayList<Eniployee>();
  ```
	* 两边都使用类型参数 Employee，这有些繁琐。Java SE 7中，可以省去右边的类型参数：
	  ```java
	  ArrayList<Employee> staff = new ArrayListoQ；
	  ```
		* 这被称为“ 菱形”语法，因为空尖括号`<>`就像是一个菱形。可以结合 new 操作符使用菱形语法。编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，编译器会检査这个变量、参数或方法的泛型类型，然后将这个类型放在o中。在这个例子中，new ArrayListo()将赋至一个类型为 ArrayList<Employee>的变量，所以泛型类型为 Employee。
* 4、数组列表管理着对象引用的一个内部数组。最终，数组的全部空间有可能被用尽。这就显现出数组列表的操作魅力：如果调用 add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。
* 5、如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法：
  ```java
  staff.ensureCapacity(lOO);
  ```
	* 这个方法调用将分配一个包含 100 个对象的内部数组。然后调用 100次 add, 而不用重新分配空间。
	* 另外，还可以把初始容量传递给 ArrayList 构造器：
	  ```
	  ArrayList<Employee> staff = new ArrayListo(lOO);
	  ```
* 6、分配数组列表，如下所示：
  ```java
  new ArrayList<>(lOO) // capacity is100
  它与为新数组分配空间有所不同：
  new Employee[100] // sizeis100
  ```
	* 数组列表的容量与数组的大小有一个非常重要的区别。如果为数组分配 100 个元素的存储空间，数组就有 100 个空位置可以使用。而容量为 100 个元素的数组列表只是拥有保存 100 个元素的潜力 （实际上，重新分配空间的话，将会超过100), 但是在最初，甚至完成初始化构造之后，数组列表根本就不含有任何元素。
* 7、size方法将返回数组列表中包含的实际元素数目。例如，
  ```java
  staff.size();
  ```
	* 将返回 staff 数组列表的当前元素数量，它等价于数组 a 的 a.length。
* 8、一旦能够确认数组列表的大小不再发生变化，就可以调用 trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。
	* 一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时，再调用 trimToSize。


### 5.3.1 访问数组列表元素