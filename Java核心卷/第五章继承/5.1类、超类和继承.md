<div align=center><h1>5.1 类、超类和继承</h1></div>

* 1、利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。
* 2、反射是指在程序运行期间发现更多的类及其属性的能力。

### 5.1.1 定义子类

* 1、由继承 Employee类来定义 Manager类的格式，关键字 extends表示继承。
  ```java
  public class Manager extends Employee{
      添加方法和域
  }
  ```
* 2、关键字 extends 表明正在构造的新类派生于一个已存在的类。
* 3、已存在的类称为超类(superclass)、基类（ base class) 或父类（parent class); 新类称为子类（subclass)、派生类(derived class) 或孩子类（child class)。
* 4、子类比超类拥有的功能更加丰富。
* 5、子类自动地继承了超类中的所有非privite的方法。
* 6、在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

### 5.1.2 覆盖方法

* 1、super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。
* 2、在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。


### 5.1.3 子类构造器

* 1、使用super调用构造器的语句必须是子类构造器的第一条语句。
* 2、如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数)的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。
* 3、关键字 this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。
* 4、super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。
* 5、调用构造器的语句只能作为另一个构造器的第一条语句出现。
* 6、构造参数既可以传递给本类（this) 的其他构造器，也可以传递给超类（super) 的构造器。
* 7、一个对象变量（例如，变量 e) 可以指示多种实际类型的现象被称为多态（polymorphism)。
* 8、在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding)。

### 5.1.4 继承层次

* 1、由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy)。
* 2、在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链 (inheritance chain)。
* 3、一个祖先类可以拥有多个子孙继承链。
* 4、Java 不支持多继承。Java 中多继承功能由接口实现。

### 5.1.5 多 态

* 1、有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a” 规则，它表明子类的每个对象也是超类的对象。
* 2、"is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。
* 3、**在 Java 程序设计语言中，对象变量是多态的**。一个 Employee 变量既可以引用一个Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象（例如，Manager、Executive、Secretary 等）。
* 4、不能将一个超类的引用赋给子类变量。
* 5、在 Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如，下面是一个经理数组：
  ```java
  Manager[] managers = new Manager[10];
  将它转换成Employee[] 数组完全是合法的：
  Employee[] staff = managers; // OK
  ```
* 6、如果 manager[i] 是一个Manager, 也一定是一个 Employee。然而，实际上，将会发生一些令人惊讶的事情。要切记managers和 staff 引用的是同一个数组。现在看一下这条语句：
  ```java
  staff[0] = new Employee("Harry Hacker", . . .);
  ```
	* 编译器竟然接纳了这个赋值操作。但在这里，staff[0] 与 manager[0] 引用的是同一个对象，似乎我们把一个普通雇员擅自归入经理行列中了。这是一种很忌伟发生的情形，当调用 managers[0].setBonus(1000) 的时候，将会导致调用一个不存在的实例域，进而搅乱相邻存储空间的内容。
	* 为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

### 5.1.6 理解方法调用

* 1、**方法的名字和参数列表称为方法的签名**。
* 2、如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。
* 3、**返回类型不是签名的一部分**，因此，在覆盖方法时，一定要保证返回类型的兼容性。
* 4、允许子类将覆盖方法的返回类型定义为原返回类型的子类型。例如，假设Employee 类有：
  ```java
  public Employee getBuddyO { . . . }
  
  public Manager getBuddyO { . . . }//OK to change return type
  ```
	* 我们说，这两个 getBuddy 方法具有可协变的返回类型。
* 5、假设要调用 x.f(args)，隐式参数 x声明为类 C的一个对象。下面是**调用过程的详细描述**：
	* 1)编译器査看对象的声明类型和方法名。假设调用 x.f(param)，且隐式参数 x声明为 C类的对象。需要注意的是：有可能存在多个名字为f, 但参数类型不一样的方法。例如，可能存在方法 f(int)和方法f(String)。编译器将会一一列举所有 C类中名为 f 的方法和其超类中访问属性为 public且名为 f 的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。
	* 2)接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析（overloading resolution)**。例如，对于调用 x.f(“Hello”）来说，编译器将会挑选 f(String)，而不是 f(int)。由于允许类型转换（int 可以转换成 double, Manager 可以转换成 Employee, 等等)，所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。至此，编译器已获得需要调用的方法名字和参数类型。
	* 3)如果是private 方法、static 方法、final方法（有关 final 修饰符的含义将在下一节讲述）或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定（static binding)**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用 f(String) 的指令。
	* 4)当程序运行，并且采用**动态绑定**调用方法时，虚拟机一定调用与 x所引用对象的实际类型最合适的那个类的方法。假设 x的实际类型是 D，它是C类的子类。如果 D类定义了方法 f(String)，就直接调用它；否则，将在 D类的超类中寻找 f(String)，以此类推。

* 6、每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表（method table), 其中列出了**所有方法的签名**和**实际调用的方法**。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。
* 7、动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类 Executive, 并且变量 e有可能引用这个类的对象，我们不需要对包含调用e.getSalary() 的代码进行重新编译。如果 e恰好引用一个 Executive类的对象，就会自动地调用 Executive.getSalary()方法。
* 8、**在覆盖一个方法的时候，子类方法不能低于超类方法的可见性**。特别是，如果超类方法是public, 子类方法一定要声明为 public。经常会发生这类错误：在声明子类方法的时候，遗漏了 public修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。

### 5.1.7 阻止继承：final 类和方法

* 1、**不允许扩展的类被称为 final 类**。如果在定义类的时候使用了 **final 修饰符**就表明这个类是 final 类。希望阻止人们定义Executive类的子类，就可以在定义这个类的时候,使用 final 修饰符声明。声明格式如下所示：
  ```java
  public final class Executive extends Manager{
       .......
  }
  ```
* 2、类中的特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法 )。例如
  ```java
  public class Employee {
    ......
    public final String getName(){
        return name;
    }
    ......
  }
  ```
* 3、域也可以被声明为 final。对于 final 域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为 final，只有其中的方法自动地成为 final,而不包括域。











