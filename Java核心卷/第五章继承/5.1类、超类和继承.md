<div align=center><h1>5.1 类、超类和继承</h1></div>

* 1、利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。
* 2、反射是指在程序运行期间发现更多的类及其属性的能力。

### 5.1.1 定义子类

* 1、由继承 Employee类来定义 Manager类的格式，关键字 extends表示继承。
  ```java
  public class Manager extends Employee{
      添加方法和域
  }
  ```
* 2、关键字 extends 表明正在构造的新类派生于一个已存在的类。
* 3、已存在的类称为超类(superclass)、基类（ base class) 或父类（parent class); 新类称为子类（subclass)、派生类(derived class) 或孩子类（child class)。
* 4、子类比超类拥有的功能更加丰富。
* 5、子类自动地继承了超类中的所有非privite的方法。
* 6、在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

### 5.1.2 覆盖方法

* 1、super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。
* 2、在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。


### 5.1.3 子类构造器

* 1、使用super调用构造器的语句必须是子类构造器的第一条语句。
* 2、如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数)的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。
* 3、关键字 this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。
* 4、super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。
* 5、调用构造器的语句只能作为另一个构造器的第一条语句出现。
* 6、构造参数既可以传递给本类（this) 的其他构造器，也可以传递给超类（super) 的构造器。
* 7、一个对象变量（例如，变量 e) 可以指示多种实际类型的现象被称为多态（polymorphism)。
* 8、在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding)。

### 5.1.4 继承层次

* 1、由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy)。
* 2、在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链 (inheritance chain)。
* 3、一个祖先类可以拥有多个子孙继承链。
* 4、Java 不支持多继承。Java 中多继承功能由接口实现。

### 5.1.5 多 态

* 1、有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a” 规则，它表明子类的每个对象也是超类的对象。
* 2、"is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。
* 3、**在 Java 程序设计语言中，对象变量是多态的**。一个 Employee 变量既可以引用一个Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象（例如，Manager、Executive、Secretary 等）。
* 4、不能将一个超类的引用赋给子类变量。
* 5、在 Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如，下面是一个经理数组：
  ```java
  Manager[] managers = new Manager[10];
  将它转换成Employee[] 数组完全是合法的：
  Employee[] staff = managers; // OK
  ```
* 6、如果 manager[i] 是一个Manager, 也一定是一个 Employee。然而，实际上，将会发生一些令人惊讶的事情。要切记managers和 staff 引用的是同一个数组。现在看一下这条语句：
  ```java
  staff[0] = new Employee("Harry Hacker", . . .);
  ```
	* 编译器竟然接纳了这个赋值操作。但在这里，staff[0] 与 manager[0] 引用的是同一个对象，似乎我们把一个普通雇员擅自归入经理行列中了。这是一种很忌伟发生的情形，当调用 managers[0].setBonus(1000) 的时候，将会导致调用一个不存在的实例域，进而搅乱相邻存储空间的内容。
	* 为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

### 5.1.6 理解方法调用

* 1、<red>**方法的名字和参数列表称为方法的签名**</red>。
















