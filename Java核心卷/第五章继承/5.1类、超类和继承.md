<div align=center><h1>5.1 类、超类和继承</h1></div>

* 1、利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。
* 2、反射是指在程序运行期间发现更多的类及其属性的能力。

### 5.1.1 定义子类

* 1、由继承 Employee类来定义 Manager类的格式，关键字 extends表示继承。
  ```java
  public class Manager extends Employee{
      添加方法和域
  }
  ```
* 2、关键字 extends 表明正在构造的新类派生于一个已存在的类。
* 3、已存在的类称为超类(superclass)、基类（ base class) 或父类（parent class); 新类称为子类（subclass)、派生类(derived class) 或孩子类（child class)。
* 4、子类比超类拥有的功能更加丰富。
* 5、子类自动地继承了超类中的所有非privite的方法。
* 6、在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

### 5.1.2 覆盖方法

* 1、super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。
* 2、在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。


### 5.1.3 子类构造器

* 1、使用super调用构造器的语句必须是子类构造器的第一条语句。
* 2、如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数)的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。
* 3、关键字 this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。
* 4、super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。
* 5、调用构造器的语句只能作为另一个构造器的第一条语句出现。
* 6、构造参数既可以传递给本类（this) 的其他构造器，也可以传递给超类（super) 的构造器。
* 7、一个对象变量（例如，变量 e) 可以指示多种实际类型的现象被称为多态（polymorphism)。
* 8、在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding)。

### 5.1.4 继承层次

* 1、由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy)。
* 2、在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链 (inheritance chain)。
* 3、一个祖先类可以拥有多个子孙继承链。
* 4、Java 不支持多继承。Java 中多继承功能由接口实现。

### 5.1.5 多 态

* 1、有一个用来判断是否应该设计为继承关系的简单规则，这就是“is-a” 规则，它表明子类的每个对象也是超类的对象。
* 2、"is-a” 规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。
* 3、**在 Java 程序设计语言中，对象变量是多态的**。一个 Employee 变量既可以引用一个Employee 类对象，也可以引用一个 Employee 类的任何一个子类的对象（例如，Manager、Executive、Secretary 等）。
* 4、不能将一个超类的引用赋给子类变量。
* 5、在 Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如，下面是一个经理数组：
  ```java
  Manager[] managers = new Manager[10];
  将它转换成Employee[] 数组完全是合法的：
  Employee[] staff = managers; // OK
  ```
* 6、如果 manager[i] 是一个Manager, 也一定是一个 Employee。然而，实际上，将会发生一些令人惊讶的事情。要切记managers和 staff 引用的是同一个数组。现在看一下这条语句：
  ```java
  staff[0] = new Employee("Harry Hacker", . . .);
  ```
	* 编译器竟然接纳了这个赋值操作。但在这里，staff[0] 与 manager[0] 引用的是同一个对象，似乎我们把一个普通雇员擅自归入经理行列中了。这是一种很忌伟发生的情形，当调用 managers[0].setBonus(1000) 的时候，将会导致调用一个不存在的实例域，进而搅乱相邻存储空间的内容。
	* 为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

### 5.1.6 理解方法调用

* 1、**方法的名字和参数列表称为方法的签名**。
* 2、如果在子类中定义了一个与超类签名相同的方法，那么子类中的这个方法就覆盖了超类中的这个相同签名的方法。
* 3、**返回类型不是签名的一部分**，因此，在覆盖方法时，一定要保证返回类型的兼容性。
* 4、允许子类将覆盖方法的返回类型定义为原返回类型的子类型。例如，假设Employee 类有：
  ```java
  public Employee getBuddyO { . . . }
  
  public Manager getBuddyO { . . . }//OK to change return type
  ```
	* 我们说，这两个 getBuddy 方法具有可协变的返回类型。
* 5、假设要调用 x.f(args)，隐式参数 x声明为类 C的一个对象。下面是**调用过程的详细描述**：
	* 1)编译器査看对象的声明类型和方法名。假设调用 x.f(param)，且隐式参数 x声明为 C类的对象。需要注意的是：有可能存在多个名字为f, 但参数类型不一样的方法。例如，可能存在方法 f(int)和方法f(String)。编译器将会一一列举所有 C类中名为 f 的方法和其超类中访问属性为 public且名为 f 的方法（超类的私有方法不可访问）。至此，编译器已获得所有可能被调用的候选方法。
	* 2)接下来，编译器将査看调用方法时提供的参数类型。如果在所有名为 f 的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为**重载解析（overloading resolution)**。例如，对于调用 x.f(“Hello”）来说，编译器将会挑选 f(String)，而不是 f(int)。由于允许类型转换（int 可以转换成 double, Manager 可以转换成 Employee, 等等)，所以这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。至此，编译器已获得需要调用的方法名字和参数类型。
	* 3)如果是private 方法、static 方法、final方法（有关 final 修饰符的含义将在下一节讲述）或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式称为**静态绑定（static binding)**。与此对应的是，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。在我们列举的示例中，编译器采用动态绑定的方式生成一条调用 f(String) 的指令。
	* 4)当程序运行，并且采用**动态绑定**调用方法时，虚拟机一定调用与 x所引用对象的实际类型最合适的那个类的方法。假设 x的实际类型是 D，它是C类的子类。如果 D类定义了方法 f(String)，就直接调用它；否则，将在 D类的超类中寻找 f(String)，以此类推。

* 6、每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表（method table), 其中列出了**所有方法的签名**和**实际调用的方法**。这样一来，在真正调用方法的时候，虚拟机仅查找这个表就行了。
* 7、动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类 Executive, 并且变量 e有可能引用这个类的对象，我们不需要对包含调用e.getSalary() 的代码进行重新编译。如果 e恰好引用一个 Executive类的对象，就会自动地调用 Executive.getSalary()方法。
* 8、**在覆盖一个方法的时候，子类方法不能低于超类方法的可见性**。特别是，如果超类方法是public, 子类方法一定要声明为 public。经常会发生这类错误：在声明子类方法的时候，遗漏了 public修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。

### 5.1.7 阻止继承：final 类和方法

* 1、**不允许扩展的类被称为 final 类**。如果在定义类的时候使用了 **final 修饰符**就表明这个类是 final 类。希望阻止人们定义Executive类的子类，就可以在定义这个类的时候,使用 final 修饰符声明。声明格式如下所示：
  ```java
  public final class Executive extends Manager{
       .......
  }
  ```
* 2、类中的特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法 )。例如
  ```java
  public class Employee {
    ......
    public final String getName(){
        return name;
    }
    ......
  }
  ```
* 3、域也可以被声明为 final。对于 final 域来说，构造对象之后就不允许改变它们的值了。不过，如果将一个类声明为 final，只有其中的方法自动地成为 final,而不包括域。
* 4、将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。
* 5、String 类也是 final 类，这意味着不允许任何人定义 String 的子类。换言之，如果有一个String 的引用，它引用的一定是一个 String 对象，而不可能是其他类的对象。

### 5.1.8  强制类型转换

* 1、**将一个类型强制转换成另外一个类型的过程被称为类型转换**。Java 程序设计语言提供了一种专门用于进行类型转换的表示法。例如：
  ```java
  double x = 3.405;
  int nx = (int) x;
  ```
	* 将表达式 x 的值转换成整数类型，舍弃了小数部分。
* 2、将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检査。
* 3、在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用instance of 操作符就可以实现。例如：
  ```java
  if (staff[1] instanceof Manager){
      boss = (Manager) staff[1]:
      ......
  }
  ```
	* **只能在继承层次内进行类型转换**。
	* **在将超类转换成子类之前，应该使用 instanceof 进行检查**。


### 5.1.9 抽象类

* 1、如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象。
* 2、包含一个或多个抽象方法的类本身必须被声明为抽象的。
  ```java
  public abstract class Person{
     ......
     public abstract String getDescription()；
  }
  ```
* 3、在抽象类中，除了抽象方法之外，抽象类还可以包含具体数据和具体方法。例如，Person类还保存着姓名和一个返回姓名的具体方法。
  ```java
  public abstract class Person{
      private String name;
      public Person(String name){
          this.name = name;
      }

      public abstract String getDescription()；

      public String getName(){
          return name;
      }
  }
  ```
* 4、抽象方法充当着占位的角色，它们的具体实现在子类中。
* 5、扩展抽象类可以有两种选择。
	* 一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；
	* 另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。
* 6、类即使不含抽象方法，也可以将类声明为抽象类。
* 7、抽象类不能被实例化。也就是说，如果将一个类声明为 abstract, 就不能创建这个类的对象。例如，表达式：
  ```java
  new Person("Vinee Vu")
  是错误的，但可以创建一个具体子类的对象。
  ```
* 8、需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。例如：
  ```java
  Person p = new Student("Vinee Vu", "Economics");
  ```
	* 这里的 p 是一个抽象类 Person 的变量，Person 引用了一个非抽象子类 Student 的实例。
* 9、由于不能构造抽象类 Person 的对象，所以变量 p 永远不会引用 Person对象，而是引用诸如 Employee或 Student 这样的具体子类对象，而这些对象中都定义了getDescription方法。
* 10、是否可以省略 Person超类中的抽象方法，而仅在 Employee和 Student 子类中定义getDescription方法呢？ 如果这样的话，就不能通过变量 p调用 getDescription方法了。编译器只允许调用在类中声明的方法。

### 5.1.10 受保护访问

* 1、在有些时候，人们希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为 protected。
* 2、受保护的方法更具有实际意义。如果需要限制某个方法的使用，就可以将它声明为protected。这表明子类（可能很熟悉祖先类）得到信任，可以正确地使用这个方法，而其他类则不行。
* 3、protected方法的一个最好的示例就是 Object类中的 clone方法。
* 4、Java用于控制可见性的 4个访问修饰符：
	* 1)仅对本类可见————private。
	* 2)对所有类可见————public。
	* 3)对本包和所有子类可见————protected。
	* 4)对本包可见————默认（很遗憾)，不需要修饰符。


























