<div align=center><h1>5.7 反射</h1></div>

* 1、反射库（reflection library) 提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵 Java代码的程序。
* 2、在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。
* 3、能够分析类能力的程序称为反射（reflective)。反射机制的功能极其强大，在下面可以看到，反射机制可以用来：
	* 在运行时分析类的能力。
	* 在运行时查看对象，例如，编写一个 toString方法供所有类使用。
	* 实现通用的数组操作代码。
	* 利用 Method对象，这个对象很像中的函数指针。

### 5.7.1 Class 类

* 1、在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为**运行时**的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。**可以通过专门的 Java类访问这些信息**。保存这些信息的类被称为 Class。Object 类中的 getClass( )方法将会返回一个Class类型的实例。
* 2、**获得 Class 类对象的三种方法**：
	* 1)Object 类中的 getClass( )方法将会返回一个 Class类型的实例。
	  ```java
	  Employee e;
	  Class cl = e.getClass();
	  ```
	* 2)调用静态方法 forName 可以获得类名对应的 Class对象。
	  ```java
	  String className = "java.util.Random";
	  Class cl = Class.forName(dassName);
	  ```
		* 如果类名保存在字符串中，并可在运行中改变，就可以使用这个方法。当然，这个方法只有在 className是类名或接口名时才能够执行。否则，forName方法将抛出一个 checked exception(已检查异常）。
		* 无论何时使用这个方法，都应该提供一个异常处理器（exception handler)。
	* 3)如果 T是任意的 Java类型（或 void关键字)，`T.class`将代表匹配的类对象。
	  ```java
	  Class cll = Random.class; //if you import java.util
	  Class cl2 = int.class;
	  Class cl3 = Double[].class;
	  ```
	* 请注意，一个 Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但 `int.class`是一个 Class类型的对象。

* 3、还有一个很有用的方法 `newlnstance()`，可以用来**动态地创建一个类的实例**,例如:
  ```java
  e.getClass().newlnstance();//创建了一个与 e 具有相同 类类型的实例。
  ```
	* newlnstance方法调用默认的构造器 （没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器，就会抛出一个异常。
	* 将 forName与 newlnstance配合起来使用，可以根据存储在字符串中的类名创建一个对象。
	  ```java
	  String s = "java.util.Random";
	  Object m = Class.forName(s).newlnstance();
	  ```
* 4、在启动时，包含 main 方法的类被加载。它会加载所有需要的类。这些被加栽的类又要加载它们需要的类，以此类推。对于一个大型的应用程序来说，这将会消耗很多时间，用户会因此感到不耐烦。
* 5、可以使用下面这个技巧给用户一种启动速度比较快的幻觉。不过，要确保包含 main方法的类没有显式地引用其他的类。首先，显示一个启动画面；然后，通过调用 Class.forName 手工地加载其他的类。
* 6、Class 类实际上是一个泛型类。例如，`Employee.class` 的类型是 `Class<Employee>`。没有说明这个问题的原因是：它将已经抽象的概念更加复杂化了。在大多数实际问题中，可以忽略类型参数。
* 7、鉴于历史原因，getName方法在应用于数组类型的时候会返回一个很奇怪的名字：
  ```java
  Double[] class.getName( );//返回"[Ljava.lang.Double;"
  int[].class.getName();//返回"[I"
  ```
* 8、虚拟机为每个类型管理一个 Class对象。因此，可以利用=运算符实现两个类对象比较的操作。例如：
  ```java
  Employee e;
  ......
  if (e.getClass()==Employee.class) . . .
  ```

```java
package com.edu.test.reflection;

import java.util.Objects;

/**
 * @Author: 王仁洪
 * @Date: 2019/3/16 20:48
 */
public class TestClassObject {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, 
            InstantiationException {
        Employee employee = new Employee();
        Class employeeGetClass = employee.getClass();

        String className = "java.util.Random";
        Class forNameClass = Class.forName(className);

        Class employeeClass = Employee.class;

        System.out.println(employeeGetClass);//class com.edu.test.reflection.Employee
        System.out.println(forNameClass);//class java.util.Random
        System.out.println(employeeClass);//class com.edu.test.reflection.Employee

        System.out.println(employeeGetClass==employeeClass);//true

        Object employeeGetClassInstance = employeeGetClass.newInstance();
        Object forNameClassInstance = forNameClass.newInstance();
        Object employeeClassInstance = employeeClass.newInstance();
        
		System.out.println(employeeGetClassInstance);
        //com.edu.test.reflection.Employee{name='null', sex='null', age=null}
        System.out.println(forNameClassInstance);
        //java.util.Random@135fbaa4
        System.out.println(employeeClassInstance);
        //com.edu.test.reflection.Employee{name='null', sex='null', age=null}

        System.out.println(employeeGetClassInstance==employeeClassInstance);//false

        Employee e1 = (Employee)employeeGetClassInstance;
        Employee e2 = (Employee)employeeClassInstance;
        System.out.println(e1.equals(e2));//true
    }
}

class Employee {
    private String name;
    private String sex;
    private Integer age;

    public Employee(){

    }

    public Employee(String name, String sex, Integer age) {
        this.name = name;
        this.sex = sex;
        this.age = age;
    }

    @Override
    public String toString() {
        return getClass().getName() + "{" +
                "name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                ", age=" + age  +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return Objects.equals(name, employee.name) &&
                Objects.equals(sex, employee.sex) &&
                Objects.equals(age, employee.age);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, sex, age);
    }
}
```

### 5.7.2 捕获异常

* 1、当程序运行过程中发生错误时，就会“ 抛出异常'抛出异常比终止程序要灵活得多，这是因为可以提供一个“ 捕获”异常的处理器 （handler) 对异常情况进行处理。
* 2、如果没有提供处理器，程序就会终止，并在控制台上打印出一条信息，其中给出了异常的类型。
* 3、异常有两种类型：未检查异常和已检查异常。
	* 对于**已检查异常**，编译器将会检查是否提供了处理器。
	* 然而，有很多常见的异常，例如，访问 null 引用，都属于**未检查异常**。编译器不会査看是否为这些错误提供了处理器。
* 4、并不是所有的错误都是可以避免的。如果竭尽全力还是发生了异常，编译器就要求提供一个处理器3 `Class.forName方法`就是一个抛出已检查异常的例子。
* 5、将可能抛出已检査异常的一个或多个方法调用代码放在try块中，然后在 catch 子句中提供处理器代码。
  ```java
  try{
      statements that might throwexceptions
  }catch (Exception e){
      handler action
  }
  ```
	* 下面是一个示例：
	  ```
	  try{
	     String name = . . .; // get class name
	     Class cl = Class.forName(name); // might throw exception
	     dosomething  with cl
	  }catch (Exception e){
	     e.printStackTraceO;
	  }
	  ```
		* 如果类名不存在，则将跳过 try 块中的剩余代码，程序直接进人 catch子句（这里，利用Throwable类的 printStackTrace方法打印出栈的轨迹。Throwable是 Exception类的超类）。如果try块中没有抛出任何异常，那么会跳过 catch子句的处理器代码。
		* 对于已检查异常，只需要提供一个异常处理器。可以很容易地发现会抛出已检査异常的方法。如果调用了一个抛出已检查异常的方法，而又没有提供处理器，编译器就会给出错误报告。

### 5.7.3 利用反射分析类的能力
* 1、反射机制最重要的内容—检查类的结构。
* 2、在`java.lang.reflect` 包中有三个类 `Field、Method 和 Constructor` 分别用于描述类的域、方法和构造器。这三个类都有一个叫做 getName的方法，用来返回项目的名称。
	* Field类有一个 getType方法，用来返回描述域所属类型的 Class对象。
	* Method和 Constructor 类有能够报告参数类型的方法。
	* Method类还有一个可以报告返回类型的方法。
	* 这三个类还有一个叫做 getModifiers 的方法，它将返回一个整型数值，用不同的位开关描述public 和 static这样的修饰符使用状况。
* 3、可以利用`java.lang.reflect` 包中的 Modifier 类的静态方法(`toString`)分析 `getModifiers` 返回的整型数值。例如，可以使用 Modifier类中的 isPublic、isPrivate或 isFinal判断方法或构造器是否是 public、private或 final。
* 4、我们需要做的全部工作就是调用 Modifier 类的相应方法，并对返回的整型数值进行分析，另外，还可以利用 `Modifier.toString`方法将修饰符打印出来。
* 5、Class类中的 getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器数组，其中包括超类的公有成员。
* 6、Class类的 getDeclareFields、getDeclareMethods和 getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。
* 7、Modifier的toString方法
  ```java
  public static String toString(int mod) {
        StringBuilder sb = new StringBuilder();
        int len;

        if ((mod & PUBLIC) != 0)        sb.append("public ");
        if ((mod & PROTECTED) != 0)     sb.append("protected ");
        if ((mod & PRIVATE) != 0)       sb.append("private ");

        /* Canonical order */
        if ((mod & ABSTRACT) != 0)      sb.append("abstract ");
        if ((mod & STATIC) != 0)        sb.append("static ");
        if ((mod & FINAL) != 0)         sb.append("final ");
        if ((mod & TRANSIENT) != 0)     sb.append("transient ");
        if ((mod & VOLATILE) != 0)      sb.append("volatile ");
        if ((mod & SYNCHRONIZED) != 0)  sb.append("synchronized ");
        if ((mod & NATIVE) != 0)        sb.append("native ");
        if ((mod & STRICT) != 0)        sb.append("strictfp ");
        if ((mod & INTERFACE) != 0)     sb.append("interface ");

        if ((len = sb.length()) > 0)    /* trim trailing space */
            return sb.toString().substring(0, len-1);
        return "";
  }
  ```
* 8、实例：
  ```java
  package com.edu.test.reflection;

  import java.lang.reflect.Constructor;
  import java.lang.reflect.Field;
  import java.lang.reflect.Method;
  import java.lang.reflect.Modifier;
  import java.util.Scanner;

  /**
   * @Author: 王仁洪
   * @Date: 2019/3/16 21:26
   */
  public class ReflectionTest {
    public static void main(String[] args) {
        // read class name from command line args or user input
        String name;
        if (args.length>0){
            name = args[0];
        }else {
            Scanner input = new Scanner(System.in);
            System.out.println("Enter class name (e.g. java.util.Date): ");
            name = input.next();
        }

        try {
            Class<?> cl = Class.forName(name);
            String clModifiers = Modifier.toString(cl.getModifiers());
            Class<?> superclass = cl.getSuperclass();

            if (clModifiers.length()>0){
                System.out.print(clModifiers + " ");
            }
            System.out.print("class " + name);
            if (superclass!=null && superclass!=Object.class){
                System.out.print(" extends " + superclass.getName());
            }
            System.out.println(" {");

            printConstructors(cl);
            System.out.println();

            printMethods(cl);

            System.out.println("}");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.exit(0);
    }

    /**
     * Prints all fields of a class
     * @param cl a class
     */
    public static void printFields(Class cl){
        Field[] clDeclaredFields = cl.getDeclaredFields();
        for (Field field : clDeclaredFields){
            String fieldModifiers = Modifier.toString(field.getModifiers());
            Class<?> fieldType = field.getType();
            String fieldName = field.getName();

            System.out.print("\t");
            if (fieldModifiers.length()>0){
                System.out.print(fieldModifiers + " ");
            }
            System.out.print(fieldType + " " + fieldName);

            System.out.println(";");
        }
    }

    /**
     * Prints all constructors of a class
     * @param cl a class
    */
    public static void printConstructors(Class cl){
        Constructor[] declaredConstructors = cl.getDeclaredConstructors();
        for (Constructor constructor : declaredConstructors){
            String constructorModifiers = Modifier.toString(constructor.getModifiers());
            String constructorName = constructor.getName();
            Class[] constructorParameterTypes = constructor.getParameterTypes();

            System.out.print("\t");
            if (constructorModifiers.length()>0){
                System.out.print(constructorModifiers + " ");
            }
            System.out.print(constructorName + "(");
            for (int i=0;i<constructorParameterTypes.length;i++){
                if (i>0){
                    System.out.print(", ");
                }
                System.out.print(constructorParameterTypes[i].getName());
            }
            System.out.println(");");
        }
    }

    /**
     * Prints all methods of a class
     * @param cl a class
     */
    public static void printMethods(Class cl){
        Method[] clDeclaredMethods = cl.getDeclaredMethods();
        for (Method method : clDeclaredMethods){
            String methodModifiers = Modifier.toString(method.getModifiers());
            String methodName = method.getName();
            Class<?>[] methodParameterTypes = method.getParameterTypes();

            System.out.print("\t");
            if (methodModifiers.length()>0){
                System.out.print(methodModifiers + " ");
            }
            System.out.print(methodName + "(");
            for (int i=0;i<methodParameterTypes.length;i++){
                if (i>0){
                    System.out.print(", ");
                }
                System.out.print(methodParameterTypes[i].getName());
            }
            System.out.println(");");
        }
    }
  }
  ```
  ```java
  Enter class name (e.g. java.util.Date): 
  java.lang.Double
  public final class java.lang.Double extends java.lang.Number {
	public static final double POSITIVE_INFINITY;
	public static final double NEGATIVE_INFINITY;
	public static final double NaN;
	public static final double MAX_VALUE;
	public static final double MIN_NORMAL;
	public static final double MIN_VALUE;
	public static final int MAX_EXPONENT;
	public static final int MIN_EXPONENT;
	public static final int SIZE;
	public static final int BYTES;
	public static final class java.lang.Class TYPE;
	private final double value;
	private static final long serialVersionUID;

	public java.lang.Double(double);
	public java.lang.Double(java.lang.String);

	public equals(java.lang.Object);
	public static toString(double);
	public toString();
	public hashCode();
	public static hashCode(double);
	public static min(double, double);
	public static max(double, double);
	public static native doubleToRawLongBits(double);
	public static doubleToLongBits(double);
	public static native longBitsToDouble(long);
	public volatile compareTo(java.lang.Object);
	public compareTo(java.lang.Double);
	public byteValue();
	public shortValue();
	public intValue();
	public longValue();
	public floatValue();
	public doubleValue();
	public static valueOf(java.lang.String);
	public static valueOf(double);
	public static toHexString(double);
	public static compare(double, double);
	public static isNaN(double);
	public isNaN();
	public static isFinite(double);
	public static isInfinite(double);
	public isInfinite();
	public static sum(double, double);
	public static parseDouble(java.lang.String);
  }

  Process finished with exit code 0
  ```
























