<div align=center><h1>6.4 内部类</h1></div>

* 1、内部类（ inner class) 是定义在另一个类中的类。为什么需要使用内部类呢？ 其主要原因有以下三点：
	* 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。
	* 内部类可以对同一个包中的其他类隐藏起来。
	* 当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较便捷。
* 2、Link 类位于 LinkedList 类的私有部分，因此，Link 对其他的代码均不可见。鉴于此情况，可以将 Link 的数据域设计为公有的，它仍然是安全的。这些数据域只能被LinkedList 类（具有访问这些数据域的合理需要）中的方法访问，而不会暴露给其他的代码。**在 Java中，只有内部类能够实现这样的控制**。
* 3、Java内部类还有另外一个功能，这使得它比 C++的嵌套类更加丰富，用途更加广泛。内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。
* 4、在 Java中，static 内部类没有这种附加指针，这样的内部类与 C++ 中的嵌套类很相似。


### 6.4.1 使用内部类访问对象状态

```java
//成员内部类
package com.edu.test.InnerClass;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Date;

/**
 * @Author: 王仁洪
 * @Date: 2019/3/20 21:17
 * A clock that prints the time in regular intervals.
 */
public class TalkingClock {
    private int interval;
    private boolean beep;

    /**
     * Constructs a talking clock
     * @param interval the interval between messages (in milliseconds)
     * @param beep true if the clock should beep
     */
    public TalkingClock(int interval,boolean beep){
        this.interval = interval;
        this.beep = beep;
    }

    /**
     * Starts the clock.
     */
    public void start(){
        ActionListener listener = new TimePrinter();
        Timer timer = new Timer(interval,listener);
        timer.start();
    }

    public class TimePrinter implements ActionListener{

        @Override
        public void actionPerformed(ActionEvent event) {
            System.out.println("At the tone, the time is " + new Date());
            if (beep){
                Toolkit.getDefaultToolkit().beep();
            }
        }
    }
}

class  InnerClassTest{
    public static void main(String[] args) {
        TalkingClock clock = new TalkingClock(1000,true);
        clock.start();

        //keep program running until user selects "0k"
        JOptionPane.showMessageDialog(null,"Quit program?");
        System.exit(0);
    }
}
```

* 1、需要注意，这里的 TimePrinter类位于 TalkingClock类内部。这并不意味着每个TalkingClock都有一个 TimePrinter实例域。
* 2、TimePrinter类没有实例域或者名为 beep的变量，取而代之的是beep引用了创建 TimePrinter 的 TalkingClock 对象的域。
* 3、内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。
* 4、内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。如图 6-3所示。

  <div align="center"><img src="./img/03.png"></div>
	* 这个引用在内部类的定义中是不可见的。然而，为了说明这个概念，我们将外围类对象的引用称为 outer。于是 actionPerformed方法将等价于下列形式：
	  ```java
	  public void actionPerformed(ActionEvent event){
	       System.out.printlnC'At the tone, the time is " + new Date());
	       if (owter.beep) 
	           Toolkit.getDefaultToolkit().beep();
	  }
	  ```
	* 外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。因为 TimePrinter类没有定义构造器，所以编译器为这个类生成了一个默认的构造器，其代码如下所示：
	  ```java
	  public TimePrinter(TalkingGock clock){//automatically generated code
	       outer = clock;
	  }
	  ```
	* **outer 不是 Java的关键字。我们只是用它说明内部类中的机制**。
	* 当在 start方法中创建了 TimePrinter 对象后，编译器就会将 this引用传递给当前的语音时钟的构造器：
	  ```java
	  ActionListener listener = new TimePrinter(this); // parameter automatically added
	  ```
* 5、TimePrinter 类声明为私有的。这样一来，只有 TalkingClock 的方法才能够构造TimePrinter 对象。
* 6、只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。


### 6.4.2 内部类的特殊语法规则

* 1、内部类有一个外围类的引用 outer。事实上，使用外围类引用的正规语法还要复杂一些。
* 2、表达式`OuterClass.this`表示外围类引用。例如，可以像下面这样编写 TimePrinter 内部类的 actionPerformed方法：
  ```java
  public void actionPerformed(ActionEvent event){
      if (TalkingClock.this,beep) 
          Toolkit.getDefaultToolkitO.beep();
  }
  ```
	* 反过来，可以采用下列语法格式更加明确地编写内部对象的构造器：
	  ```java
	  outerObject.n&H InnerClass{construction parameters)
	  ```
	* 例如:
	  ```java
	  ActionListener listener = this.newTimePrinter();
	  ```
* 3、需要注意，在外围类的作用域之外，可以这样引用内部类：
  ```java
  OuterClass.InnerClass
  ```
* 4、**内部类中声明的所有静态域都必须是 final**。原因很简单。我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是 final, 它可能就不是唯一的。
* 5、**内部类不能有 static方法**。Java语言规范对这个限制没有做任何解释。也可以允许有静态方法，但只能访问外围类的静态域和方法。显然，Java设计者认为相对于这种复杂性来说，它带来的好处有些得不偿失。

### 6.4.3 内部类是否有用、必要和安全

* 1、当在 Java 1.1 的 Java语言中增加内部类时，很多程序员都认为这是一项很主要的新特性，但这却违背了 Java要比 C++更加简单的设计理念。内部类的语法很复杂。
* 2、由于增加了一些看似优美有趣，实属没必要的特性，似乎 Java也开始走上了许多语言饱受折磨的毁灭性道路上。
* 3、**内部类是一种编译器现象，与虚拟机无关**。编译器将会把内部类翻译成用 `$` (美元符号）分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。
* 4、例如，在 TalkingClock类内部的 TimePrinter类将被翻译成类文件 `TalkingClock$TimePrinter.class`。 
* 5、为了能够看到执行的效果，可以做一下这个实验：运行`javap`命令,并将类`TalkingClock$TimePrinter`传递给它进行反射。
  ```java
  javap -private TalkingClock$TimePrinter
  ```
  
  <div align="center"><img src="./img/04.png"/></div>
* 6、
* 7、
* 8、
* 9、
* 





























































