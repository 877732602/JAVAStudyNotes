<div align=center><h1>6.1 接口</h1></div>

* 1、**接口（interface) **技术，主要用来描述类具有什么功能，而并不给出每个功能的具体实现。
* 2、一个类可以实现（implement) —个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。
* 3、**lambda 表达式**，是一种表示可以在将来某个时间点执行的代码块的简洁方法。
* 4、使用 lambda 表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。
* 5、**内部类**定义在另外一个类的内部，其中的方法可以访问包含它们的外部类的域。
* 6、**代理（proxy)**, 是一种实现任意接口的对象。代理是一种非常专业的构造工具，它可以用来构建系统级的工具。


### 6.1.1 接口概念

* 1、在 Java程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。
* 2、Arrays类中的 sort方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了 Comparable 接口。下面是 Comparable 接口的代码：
  ```java
  //JavaSE 5.0 以后
  public interface Comparable<T> {
     public int compareTo(T o);
  }
  
  //JavaSE 5.0 以前
  public interface Comparable{
     int compareTo(Object other);
  }
  ```
	* 这就是说，任何实现 Comparable接口的类都需要包含 compareTo方法，并且这个方法的参数必须是一个 Object 对象，返回一个整型数值。
* 3、接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字 public。
* 4、接口中还有一个没有明确说明的附加要求：在调用 `x.compareTo(y)` 的时候，这个compareTo方法必须确实比较两个对象的内容，并返回比较的结果。当 x 小于 y时，返回一个负数；当 x 等于 y时，返回 0；否则返回一个正数。
* 5、在**接口中还可以定义常量**。//与接口中的方法都自动地被设置为public—样，接口中的域将被自动设为public static final。
  ```java
  public final Integer AGE = 20;
  等价于
  Integer AGE = 20;（可以省略public、static和final修饰符）
  ```
* 6、接口绝不能含有实例域，在 JavaSE 8之前，也不能在接口中实现方法。（现在已经可以在接口中提供简单方法了。当然，这些方法不能引用实例域——接口没有实例。）
  ```java
  package com.edu.test.interfacetest;

  /**
   * @Author: 王仁洪
   * @Date: 2019/3/17 21:22
   */
  public interface Interface {
    //public static final Integer AGE = 20;
    Integer AGE = 20;
    
    void fun1();
    Integer fun2();

    static void fun(){
        System.out.println("Interface.fun()");
    }
  }
  class TestInterface{
    public static void main(String[] args) {
        System.out.println(Interface.AGE);//20
        Interface.fun();//Interface.fun()
    }
  }  
  ```
* 7、提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此，可以将接口看成是没有实例域的抽象类=但是这两个概念还是有一定区别的。
* 8、现在，假设希望使用 Arrays类的 sort 方法对 Employee对象数组进行排序，Employee类就必须实现 Comparable接口。为了让类实现一个接口，通常需要下面两个步骤：
	* 1)将类声明为实现给定的接口。
	* 2)对接口中的所有方法进行定义。
	* 要将类声明为实现某个接口，需要使用关键字 implements:
	  ```java
	  class Employee iipleients Comparable
	  ```
	* 当然，这里的 Employee类需要提供 compareTo 方法。假设希望根据雇员的薪水进行比较。以下是compareTo方法的实现:
	  ```java
	  public int compareTo(Object otherObject){
	      Employee other = (Employee) otherObject;
	      return Double.compare(salary, other.salary);
	  }
	  ```
		* 在这里，我们使用了静态 Double.compare方法，如果第一个参数小于第二个参数，它会返回一个负值；如果二者相等则返回 0; 否则返回一个正值。
* 9、在接口声明中，没有将 compareTo方法声明为 public, 这是因为在接口中的所有方法都自动地是public。不过，在实现接口时，必须把方法声明为 pubHc; 否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更严格的访问权限的警告信息。
* 10、我们可以做得更好一些。可以为泛型 Comparable接口提供一个类型参数。
  ```java
  class Employee implements Comparable<Employee>{
      public int compareTo(Employee other){
	      return Double.compare(salary, other.salary);
	  }
  }
  ```
* 11、如果能够确信 需要比较的量 为非负整数，或者它们的绝对值不会超过（Integer_MAX_VALUE-1)/2，利用相减技巧 就不会出现问题。否则，调用静态 Integer.compare方法。（相减技巧不适用于浮点值。）
* 12、要让一个类使用排序服务必须让它实现 compareTo 方法。因为要向 sort方法提供对象的比较方式。但是为什么不能在 Employee类直接提供一个 compareTo方法，而必须实现 Comparable接口呢？
	* 主要原因在于 Java程序设计语言是一种强类型（strongly typed) 语言。在调用方法的时候，编译器将会检查这个方法是否存在。在 sort方法中可能存在下面这样的语句：
	  ```java
	  if (a[i].compareTo(a[j]) > 0){
	        // rearrange a[i] and a[j]
	  }
	  ```
	* 为此，编译器必须确认 a[i] —定有 compareTo 方法。如果 a 是一个 Comparable 对象的数组，就可以确保拥有 compareTo方法，因为每个实现 Comparable 接口的类都必须提供这个方法的定义。

```java
package com.edu.test.interfacetest;

import java.util.Arrays;

/**
 * @Author: 王仁洪
 * @Date: 2019/3/17 21:20
 */
public class Employee implements Comparable<Employee> {
    private String name;
    private double salary;

    public Employee(String name,double salary){
        this.name = name;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public void raiseSalary(double byPercent){
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    @Override
    public String toString() {
        return getClass().getName() + "{" +
                "name='" + name + '\'' +
                ", salary=" + salary +
                '}';
    }

    /**
     * Compares employees by salary
     * @param other another Employee object
     * @return a negative value if this employee has a lower salary than
     * otherObject, 0 if the salaries are the same, a positive value otherwise
     */
    @Override
    public int compareTo(Employee other) {
        return Double.compare(salary,other.salary);
    }
}

class EmployeeSortTest{
    public static void main(String[] args) {
        Employee[] staff = new Employee[3];

        staff[0] = new Employee("Harry Hacker", 35000);
        staff[1] = new Employee("Carl Cracker", 75000);
        staff[2] = new Employee("Tony Tester", 38000) ;

        Arrays.sort(staff);

        for (Employee employee : staff){
            System.out.println(employee);
        }
        /**
         * com.edu.test.interfacetest.Employee{name='Harry Hacker', salary=35000.0}
         * com.edu.test.interfacetest.Employee{name='Tony Tester', salary=38000.0}
         * com.edu.test.interfacetest.Employee{name='Carl Cracker', salary=75000.0}
         */
    }
}
```

### 6.1.2 接口的特性

* 1、接口不是类，尤其不能使用 new运算符实例化一个接口：
  ```java
  x = new Comparable(.. .); // ERROR
  ```
* 2、能声明接口的变量：
  ```java
  Comparable x; // OK
  ```
* 3、接口变量必须弓I用实现了接口的类对象：
  ```java
  x = new Employee(. . .); // OK provided Employee implements Comparable
  ```
* 4、接下来，如同使用 instanceof检查一个对象是否属于某个特定类一样，也可以使用instance检查一个对象是否实现了某个特定的接口：
  ```java
  if (anObject instanceof Comparable) { 
       . . . 
  }
  ```
* 5、与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。
* 6、虽然在接口中不能包含实例域*或静态方法*（斜体部分对错如何解释），但却可以包含常量。例如：
  ```java
  public interface Powered extends Moveable{
      double milesPerCallonO;
      double SPEED.LIHIT = 95; // a public static final constant
  }
  ```
	* 与接口中的方法都自动地被设置为 public—样，接口中的域将被自动设为 public、static、final。
  
  ```java
  /**
   * @Author: 王仁洪
   * @Date: 2019/3/17 21:22
   */
  public interface Interface {
    //public static final Integer AGE = 20;
    Integer AGE = 20;
    //public static final Map map = new HashMap();
    Map map = new HashMap();

    void fun1();
    Integer fun2();

    static void fun(){
        System.out.println("Interface.fun()");
    }
  }  
  ```
* 7、尽管每个类只能够拥有一个超类，但却可以实现多个接口。这就为定义类的行为提供了极大的灵活性。
* 8、Java程序设计语言有一个非常重要的内置接口，称为 Cloneable 。如果某个类实现了这个 Cloneable接口，Object 类中的 clone方法就可以创建类对象的一个拷贝。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了: 使用逗号将实现的各个接口分隔开。
  ```java
  class Employee implements Cloneable, Comparable
  ```

### 6.1.3 接口与抽象类

* 1、
* 2、
* 3、
* 4、
* 5、
* 6、
* 7、
* 8、
* 9、
* 10、
* 11、
* 12、
* 13、
* 14、
* 15、



















































































































