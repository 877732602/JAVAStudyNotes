<div align=center><h1>6.5 代理</h1></div>

### 6.5.1 何时使用代理

* 1、利用代理可以在运行时创建一个实现了一组给定接口的新类: 这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。
* 2、**代理类可以在运行时创建全新的类**。这样的代理类能够实现指定的接口。尤其是，它具有下列方法：
	* 指定接口所需要的全部方法。
	* Object 类中的全部方法，例如，toString、equals 等。
* 3、然而，不能在运行时定义这些方法的新代码。而是要提供一个调用处理器（invocation handler)。调用处理器是实现了 InvocationHandler接口的类对象。在这个接口中只有一个方法：
  ```java
  Object invoke(Object proxy, Method method, Object[] args)
  ```
	* 无论何时调用代理对象的方法，调用处理器的 invoke方法都会被调用，并向其传递Method 对象和原始的调用参数。调用处理器必须给出处理调用的方式。

### 6.5.2 创建代理对象

* 1、要想创建一个代理对象，需要使用 Proxy 类的 newProxylnstance 方法。这个方法有三个参数：
	* 一个类加栽器（class loader)。作为 Java安全模型的一部分，对于系统类和从因特网上下载下来的类，可以使用不同的类加载器。目前，用 null 表示使用默认的类加载器。
	* 一个 Class对象数组，每个元素都是需要实现的接口。
	* 一个调用处理器。
* 2、还有两个需要解决的问题。如何定义一个处理器？ 能够用结果代理对象做些什么？ 当然，这两个问题的答案取决于打算使用代理机制解决什么问题。使用代理可能出于很多原因，例如：
	* 路由对远程服务器的方法调用。
	* 在程序运行期间，将用户接口事件与动作关联起来。
	* 为调试，跟踪方法调用。

##3 6.5.3 代理类的特性

* 1、代理类是在程序运行过程中创建的。然而，一旦被创建，就变成了常规类，与虚拟机中的任何其他类没有什么区别。
* 2、**所有的代理类都扩展于 Proxy类**。一个代理类只有一个实例域—调用处理器，它定义在 Proxy 的超类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。
* 3、所有的代理类都覆盖了 Object类中的方法 toString、equals和 hashCode。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的 invoke。Object 类中的其他方法（如 clone和 getClass) 没有被重新定义。
* 4、没有定义代理类的名字，Sun 虚拟机中的 Proxy类将生成一个以字符串 SProxy开头的类名。
* 5、对于特定的类加载器和预设的一组接口来说，只能有一个代理类。也就是说，如果使用同一个类加载器和接口数组调用两次 newProxylustance方法的话，那么只能够得到同一个类的两个对象，也可以利用getProxyClass方法获得这个类：
  ```java
  Class proxyClass = Proxy.getProxyClass(null, interfaces);
  ```
* 6、代理类一定是 public和 final。如果代理类实现的所有接口都是 public，代理类就不属于某个特定的包；否则，所有非公有的接口都必须属于同一个包，同时，代理类也属于这个包。
* 7、可以通过调用 Proxy 类中的 isProxyClass方法检测一个特定的 Class对象是否代表一个代理类。
















































