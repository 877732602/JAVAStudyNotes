<div align=center><h1>6.3 lambda表达式</h1></div>

### 6.3.1 为什么引入 lambda表达式

* 1、lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。
* 2、在 Java 中传递一个代码段并不容易，不能直接传递代码段 _ Java 是一种面向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码=
* 3、Java 的强大之处就在于其简单性和一致性。
* 4、就现在来说，问题已经不是是否增强 Java 来支持函数式编程，而是要如何做到这一点。

### 6.3.2 lambda 表达式的语法

* 1、**Java 是一种强类型语言**。
* 2、传人代码来检查一个字符串是否比另一个字符串短。这里要计算：
  ```java
  first.lengthO-second.length()
  ```
	* first 和 second是什么？ 它们都是字符串。Java 是一种强类型语言，所以我们还要指定它们的类型：
	  ```java
	  (String first, String second)-> 
          first.length() - second.length()
	  ```
	* 这就是你看到的第一个 lambda 表达式。lambda 表达式就是一个代码块，以及必须传人代码的变量规范。
* 3、带参数变量的表达式就被称为 lambda表达式。
* 4、你已经见过 Java中的一种 lambda表达式形式：`参数，箭头（->) 以及一个表达式`。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 `{}`中，并包含显式的 return语句。例如：
  ```java
  (String first, String second) ->{
       if (first.length() < second.length()) return -1;
       else if (first.length() > second.length() return 1;
       else return 0;
  }
  ```
* 5、即使 lambda表达式没有参数，仍然要提供空括号，就像无参数方法一样：
  ```java
  () ->{ 
     for (inti = 100;i>= 0;i ) 
         System.out.println(i); 
  }
  ```
* 6、如果可以推导出一个 lambda表达式的参数类型，则可以忽略其类型。例如：
  ```java
  Comparator<String> comp
  =(first, second)// Same as (String first, String second)
  -> first.length() - second.length();
  ```
	* 在这里，编译器可以推导出 first 和 second必然是字符串，因为这个 lambda表达式将赋给一个字符串比较器。
* 7、如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：
  ```java
  ActionListener listener = event ->
     System.out.println("The time is "+new Date()");
    // Instead of (event) -> . . . or (ActionEvent event) -> . . .
  ```
* 8、无需指定 lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。例如，下面的表达式
  ```java
  (String first, String second) -> first.length() - second.length()
  ```
	* 可以在需要 int 类型结果的上下文中使用。
* 9、如果一个 lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。例如，`（int x)-> { if(x>=0) return1;}` 就不合法。







































