<div align="center"><h1>14.3 线程状态</h1></div>


* 线程可以有如下 6种状态：

<div align="center"><img src="./img/001.png"/></div>

### 14.3.1 新创建线程
* 1、当用 new操作符创建一个新线程时，如 newThread(r)，该线程还没有开始运行。这意味着它的状态是 new。
* 2、当一个线程处于**新创建状态**时，程序还没有开始运行线程中的代码。
* 3、在线程运行之前还有一些基础工作要做。


### 14.3.2 可运行线程
* 1、一旦调用 start方法，线程处于 **runnable 状态**。一个可运行的线桿**可能正在运行也可能没有运行**，这取决于操作系统给线程提供运行的时间。
	* Java的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行状态。
* 2、一旦一个线程开始运行，它不必始终保持运行。
	* 事实上，**运行中的线程被中断，目的是为了让其他线程获得运行机会**。
	* 线程调度的细节依赖于操作系统提供的服务。
	* 抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会（见图 14-4)。当选择下一个线程时，操作系统考虑线程的优先级。
  <div align="center"><img src="./img/14-4.png"/></div>
* 3、现在所有的桌面以及服务器操作系统都使用抢占式调度。
* 4、但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在**调用 yield方法、或者被阻塞或等待时，线程才失去控制权**。
* 5、在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程**并行运行**。当然，如果线程的数目多于处理器的数目，调度器依然采用时间片机制。
* 6、记住，在任何给定时刻，二个可运行的线程可能正在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行)。






















































































































































