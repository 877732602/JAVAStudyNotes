<div align="center"><h1>14.4 线程属性</h1></div>

### 14.4.1 线程优先级
* 1、在 Java 程序设计语言中，每一个线程有一个优先级。
* 2、默认情况下，一+线程继承它的父线程的优先级。
* 3、可以用 setPriority 方法提高或降低任何一个线程的优先级。
* 4、可以将优先级设置为在：
	*  **MIN_PRIORITY (在 Thread 类中定义为 1)** 与 
	*  **MAX_PRIORITY (定义为 10)** 之间的任何值。
	*  **NORM_PRIORITY 被定义为 5**。
* 5、每当线程调度器有机会选择新线程时，它**首先选择具有较高优先级的线程**。但是，线程优先级是高度依赖于系统的。
* 6、当虚拟机依赖于宿主机平台的线程实现机制时，Java 线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。
* 7、例如：
	* Windows 有 7个优先级别。一些 Java 优先级将映射到相同的操作系统优先级。
	* 在Oracle 为 Linux 提供的 Java 虚拟机中，线程的优先级被忽略一所有线程具有相同的优先级。
* 8、如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。
* 9、每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程完全饿死。

### 14.4.2 守护线程
* 1、可以通过调用
  ```java
  t.setDaemon(true);
  ```
	* 将线程转换为**守护线程（daemonthread)**。
* 2、**守护线程的唯一用途是为其他线程提供服务**。
* 3、当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了。

### 14.4.3 未捕获异常处理器
* !、线程的 run方法不能抛出任何受查异常，但是，非受査异常会导致线程终止。在这种情况下，线程就死亡了。
* 2、不需要任何 catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的**处理器**。
* 3、该处理器必须属于一个实现 Thread.UncaughtExceptionHandler接口的类。这个接口只有一个方法。
  ```java
  void uncaughtException(Thread t, Throwable e)
  ```
* 4、可以:
	* 用 setUncaughtExceptionHandler方法为任何线程安装一个处理器。
	* 也可以用 Thread类的静态方法 setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器。
* 5、替换处理器可以使用日志 API 发送未捕获异常的报告到日志文件。
* 6、如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup对象。
* 7、线程组是一个可以统一管理的线程集合。
	* 默认情况下，创建的所有线程属于相同的线程组，
	* 但是，也可能会建立其他的组。
	* **现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组**。
* 8、ThreadGroup类实现 Thread.UncaughtExceptionHandler 接口。它的 uncaughtException方法做如下操作：
	* 1）如果该线程组有父线程组，那么父线程组的 uncaughtException方法被调用。
	* 2) 否则，如果 Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用该处理器。
	* 3) 否则，如果 Throwable是 ThreadDeath的一个实例，什么都不做。
	* 4) 否则，线程的名字以及 Throwable的栈轨迹被输出到 System.err 上。


































































































