<div align="center"><h1>14.5 同步</h1></div>

### 14.5.1 竞争条件的一个例子
* 1、为了避免多线程引起的对共享数据的说误，必须学习如何**同步存取**。

### 14.5.2 竞争条件详解

* 1、假定两个线程同时执行指令
  ```java
  accounts[to] += amount;
  ```
	* 问题在于这不是原子操作。该指令可能被处理如下：
		* 1)将 accounts[to] 加载到寄存器。
		* 2)增 加 amount。
		* 3)将结果写回 accounts[to]。
	* 现在，假定第 1 个线程执行步骤 1 和 2, 然后，它被剥夺了运行权。假定第 2个线程被唤醒并修改了 accounts 数组中的同一项。然后，第 1个线程被唤醒并完成其第 3步。
	* 这样，这一动作擦去了第二个线程所做的更新。于是，总金额不再正确。（见图 14-4J

  <div align="center"><img src="./img/14-4.png"/></div>
* 2、真正的问题是 transfer方法的执行过程中可能会被中断。
* 3、**如果能够确保线程在失去控制之前方法运行完成**，那么银行账户对象的状态永远不会出现讹误。

### 14.5.3 锁对象

* 1、有两种机制**防止代码块受并发访问的干扰**。
	* Java语言提供一个 synchronized关键字达到这一目的，
	* 并且 Java SE 5.0引入了 ReentrantLock类
* 2、synchronized关键字自动提供一个锁以及相关的“ 条件”，对于大多数需要显式锁的情况，这是很便利的。
* 3、用 ReentrantLock 保护代码块的基本结构如下：
  ```java
  private Lock myLock = new ReentrantLock();// ReentrantLock implements the Lock interface
  myLock.lock();//a ReentrantLock object
  try {
      critical section
  } finally {
      myLock.unlock();// make sure the lock is unlocked even if an exception is thrown
  }
  ```
	* 这一结构确保任何时刻只有一个线程进人临界区。
	* 一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock语句。
	* 当其他线程调用 lock时，它们被阻塞，直到第一个线程释放锁对象。
	* 把**解锁操作**括在 finally子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。
* 4、**锁是可重入的，因为线程可以重复地获得已经持有的锁**。
* 5、锁保持一个持有计数（hold count) 来跟踪对 lock 方法的嵌套调用。**线程在每一次调用 lock 都要调用 unlock 来释放锁**。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。
* 6、要留心临界区中的代码，不要因为异常的抛出而跳出临界区。如果在临界区代码结束之前抛出了异常，finally 子句将释放锁，但会使对象可能处于一种受损状态。
* 7、构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。
  ```java
  ReentrantLock(boo1ean fair)
  ```
	* 听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。
	* 只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候，才可以使用公平锁。
	* 即使使用公平锁，也无法确保线程调度器是公平的。
	* 如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了。

### 14.5.4 条件对象

* 1、通常，线程进人临界区，却发现在某一条件满足之后它才能执行。
* 2、要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。
* 3、由于历史的原因，**条件对象经常被称为条件变量（conditional variable)**。

```java
程序清单 14-7 com/edu/test/multithreading/SynchBankTest.java

package com.edu.test.multithreading;

import java.util.Arrays;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author: 王仁洪
 * @Date: 2019/4/1 17:51
 */
public class SynchBankTest {
    public static final int NACCOUNTS = 100;
    public static final double INITIAL_BALANCE = 1000;
    public static final double MAX_AMOUNT = 1000;
    public static final int DELAY = 10;

    public static void main(String[] args) {
        Bank bank = new Bank(NACCOUNTS,INITIAL_BALANCE);
        for (int i=0;i<NACCOUNTS;i++){
            int fromAccount = i;
            Runnable r = ()->{
                try {
                    while (true){
                        int toAccount = (int) (bank.size() * Math.random());
                        double amount = MAX_AMOUNT * Math.random();
                        bank.transfer(fromAccount, toAccount, amount);
                        Thread.sleep((int) (DELAY * Math.random()));
                    }
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            };
            Thread thread =  new Thread(r);
            thread.start();
        }
    }
}
class Bank{
    private final double[] accounts;
    private Lock bankLock;
    private Condition sufficientFunds;

    /**
     * Constructs the bank.
     * @param n the number of accounts
     * @param initialBalance the initial balance for each account
     */
    public Bank(int n,double initialBalance){
        accounts = new double[n];
        Arrays.fill(accounts,initialBalance);
        bankLock = new ReentrantLock();
        sufficientFunds = bankLock.newCondition();
    }

    /**
     * Transfers money from one account to another.
     * @param from the account to transfer from
     * @param to the account to transfer to
     * @param amount the amount to transfer
     */
    public void transfer(int from,int to,double amount) throws InterruptedException {
        bankLock.lock();
        try {
            while (accounts[from] < amount) {
                sufficientFunds.await();
            }
            System.out.print(Thread.currentThread());
            accounts[from] -= amount;
            System.out.printf("%10.2f from %d to %d",amount,from,to);
            accounts[to] += amount;
            System.out.printf("Total Balance: %10.2f %n",getTotalBalance());
            sufficientFunds.signalAll();
        }finally {
            bankLock.unlock();
        }
    }

    /**
     * Gets the sum of all account balances.
     * @return the total balance
     */
    public double getTotalBalance(){
        bankLock.lock();
        try {
            double sum = 0;
            for (double a : accounts){
                sum += a;
            }
            return sum;
        }finally {
            bankLock.unlock();
        }
    }

    /**
     * Gets the number of accounts in the bank.
     * @return the number of accounts
     */
    public int size(){
        return accounts.length;
    }
}
```

### 14.5.5 synchronized 关键字

* 1、有关锁和条件的关键之处：
	* 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。
	* 锁可以管理试图进入被保护代码段的线程。
	* 锁可以拥有一个或多个相关的条件对象。
	* 每个**条件对象**管理那些已经进入被保护的代码段但还不能运行的线程。
* 2、Lock 和 Condition接口为程序设计人员提供了高度的锁定控制。
* 3、如果一个方法用 synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。
  ```java
  换句话说，
  public synchronized void method(){
      method body
  }
  等价于：
  public void method(){
      this.intrinsidock.lock();
      try {
          method body
      }
      finally { 
          this.intrinsicLock.unlock(); 
      }
  }
  ```
* 4、内部对象锁只有一个相关条件。**wait方法添加一个线程到等待集中**，**notifyAll /notify方法解除等待线程的阻塞状态**。换句话说，调用 wait 或 notityAll 等价于
  ```java
  intrinsicCondition.await();
  intrinsicCondition.signalAll();
  ```
* 5、wait、notifyAll以及notify方法是Object 类的 final 方法。Condition方法必须被命名为 await、signalAll 和signal 以便它们不会与那些方法发生冲突。
* 6、由锁来管理那些试图进入 synchronized 方法的线程，由条件来管理那些调用 wait 的线程。
* 7、将静态方法声明为synchronized也是合法的。如果调用这种方法，该方法获得相关的**类对象的内部锁**。
	* 例如，如果 Bank 类有一个静态同步的方法，那么当该方法被调用时，`Bank.class`对象的锁被锁住。
	* 因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。
* 8、内部锁和条件存在一些局限。包括：
	* 不能中断一个正在试图获得锁的线程。
	* 试图获得锁时不能设定超时。
	* 每个锁仅有单一的条件，可能是不够的。
* 9、在代码中应该使用哪一种？ Lock 和 Condition 对象还是同步方法？下面是一些建议：
	* 最好既不使用 Lock/Condition 也不使用 synchronized 关键字。在许多情况下你可以使用java.util.concurrent 包中的一种机制，它会为你处理所有的加锁。例如，在 14.6节，你会看到如何使用阻塞队列来同步完成一个共同任务的线程。还应当研究一下并行流，有关内容参见卷II第 1 章。
	* 如果 synchronized 关键字适合你的程序，那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率。程序清单 14-8给出了用同步方法实现的银行实例。
	* 如果特别需要 Lock/Condition结构提供的独有特性时，才使用 Lock/Condition。






































































































