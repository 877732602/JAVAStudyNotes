<div align="center"><h1>14.5 同步</h1></div>

### 14.5.1 竞争条件的一个例子
* 1、为了避免多线程引起的对共享数据的说误，必须学习如何**同步存取**。

### 14.5.2 竞争条件详解

* 1、假定两个线程同时执行指令
  ```java
  accounts[to] += amount;
  ```
	* 问题在于这不是原子操作。该指令可能被处理如下：
		* 1)将 accounts[to] 加载到寄存器。
		* 2)增 加 amount。
		* 3)将结果写回 accounts[to]。
	* 现在，假定第 1 个线程执行步骤 1 和 2, 然后，它被剥夺了运行权。假定第 2个线程被唤醒并修改了 accounts 数组中的同一项。然后，第 1个线程被唤醒并完成其第 3步。
	* 这样，这一动作擦去了第二个线程所做的更新。于是，总金额不再正确。（见图 14-4J

  <div align="center"><img src="./img/14-4.png"/></div>
* 2、真正的问题是 transfer方法的执行过程中可能会被中断。
* 3、**如果能够确保线程在失去控制之前方法运行完成**，那么银行账户对象的状态永远不会出现讹误。

### 14.5.3 锁对象

* 1、有两种机制**防止代码块受并发访问的干扰**。
	* Java语言提供一个 synchronized关键字达到这一目的，
	* 并且 Java SE 5.0引入了 ReentrantLock类
* 2、synchronized关键字自动提供一个锁以及相关的“ 条件”，对于大多数需要显式锁的情况，这是很便利的。
* 3、用 ReentrantLock 保护代码块的基本结构如下：
  ```java
  private Lock myLock = new ReentrantLock();// ReentrantLock implements the Lock interface
  myLock.lock();//a ReentrantLock object
  try {
      critical section
  } finally {
      myLock.unlock();// make sure the lock is unlocked even if an exception is thrown
  }
  ```
	* 这一结构确保任何时刻只有一个线程进人临界区。
	* 一旦一个线程封锁了锁对象，其他任何线程都无法通过 lock语句。
	* 当其他线程调用 lock时，它们被阻塞，直到第一个线程释放锁对象。
	* 把**解锁操作**括在 finally子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。
* 4、**锁是可重入的，因为线程可以重复地获得已经持有的锁**。
* 5、锁保持一个持有计数（hold count) 来跟踪对 lock 方法的嵌套调用。**线程在每一次调用 lock 都要调用 unlock 来释放锁**。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。
* 6、要留心临界区中的代码，不要因为异常的抛出而跳出临界区。如果在临界区代码结束之前抛出了异常，finally 子句将释放锁，但会使对象可能处于一种受损状态。
* 7、构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。
  ```java
  ReentrantLock(boo1ean fair)
  ```
	* 听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。
	* 只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须使用公平锁的时候，才可以使用公平锁。
	* 即使使用公平锁，也无法确保线程调度器是公平的。
	* 如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了。

### 14.5.4 条件对象

* 1、
* 2、
* 3、
* 4、
* 5、
* 6、
* 7、
* 8、
* 






































































































